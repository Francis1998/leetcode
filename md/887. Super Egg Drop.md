可同化成许多个小问题，楼层还剩多少时

F在i上下有两种情况，取个最大值确保即可

dp[K] [i] = min (dp[K] [i] , max(dp[i-1] [k-1]+1,dp[i] [j-k]+1 ))

这种情况会超时

需要转换思路

搭配dp[M] [K] K个鸡蛋扔M次所能检测到的楼层数>=N

于是 while dp[m] [k]<N：

​		m+=1 #m=0初始

​		for i in range(1,K+1): #从一个鸡蛋到K个扔m次

​			dp[m] [i] = dp[m-1] [i-1]  + 1#碎了，F能多判断一层，向下扫 +dp[m-1] [i] #扔了没碎，F不能多判断，向上搜索

return m





